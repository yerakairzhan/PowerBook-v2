// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: readings.sql

package db

import (
	"context"
	"time"
)

const createReadingLog = `-- name: CreateReadingLog :exec
INSERT INTO reading_logs (userid, username, date, minutes_read)
VALUES (
           $1,$2, $3, $4
       )
`

type CreateReadingLogParams struct {
	Userid      string    `json:"userid"`
	Username    string    `json:"username"`
	Date        time.Time `json:"date"`
	MinutesRead int32     `json:"minutes_read"`
}

func (q *Queries) CreateReadingLog(ctx context.Context, arg CreateReadingLogParams) error {
	_, err := q.db.ExecContext(ctx, createReadingLog,
		arg.Userid,
		arg.Username,
		arg.Date,
		arg.MinutesRead,
	)
	return err
}

const getReadingLogsByUser = `-- name: GetReadingLogsByUser :many
SELECT date, minutes_read
FROM reading_logs
WHERE userid = $1
ORDER BY date DESC
`

type GetReadingLogsByUserRow struct {
	Date        time.Time `json:"date"`
	MinutesRead int32     `json:"minutes_read"`
}

func (q *Queries) GetReadingLogsByUser(ctx context.Context, userid string) ([]GetReadingLogsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getReadingLogsByUser, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReadingLogsByUserRow
	for rows.Next() {
		var i GetReadingLogsByUserRow
		if err := rows.Scan(&i.Date, &i.MinutesRead); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopReaders = `-- name: GetTopReaders :many
SELECT u.username, SUM(rl.minutes_read) AS total_minutes
FROM users u
         JOIN reading_logs rl ON u.userid = rl.userid
GROUP BY u.username
ORDER BY total_minutes DESC
    LIMIT 3
`

type GetTopReadersRow struct {
	Username     string `json:"username"`
	TotalMinutes int64  `json:"total_minutes"`
}

func (q *Queries) GetTopReaders(ctx context.Context) ([]GetTopReadersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopReaders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopReadersRow
	for rows.Next() {
		var i GetTopReadersRow
		if err := rows.Scan(&i.Username, &i.TotalMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopReadersThisMonth = `-- name: GetTopReadersThisMonth :many
SELECT u.username, SUM(rl.minutes_read) AS total_minutes
FROM users u
         JOIN reading_logs rl ON u.userid = rl.userid
WHERE rl.date >= date_trunc('month', CURRENT_DATE)  -- Start of the current month
  AND rl.date < date_trunc('month', CURRENT_DATE + INTERVAL '1 month')  -- Start of next month
GROUP BY u.username
ORDER BY total_minutes DESC
    LIMIT 3
`

type GetTopReadersThisMonthRow struct {
	Username     string `json:"username"`
	TotalMinutes int64  `json:"total_minutes"`
}

func (q *Queries) GetTopReadersThisMonth(ctx context.Context) ([]GetTopReadersThisMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopReadersThisMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopReadersThisMonthRow
	for rows.Next() {
		var i GetTopReadersThisMonthRow
		if err := rows.Scan(&i.Username, &i.TotalMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopStreaks = `-- name: GetTopStreaks :many
WITH consecutive_days AS (
    SELECT
        rl.userid,
        rl.date,
        ROW_NUMBER() OVER (PARTITION BY rl.userid ORDER BY rl.date)
            - EXTRACT(DAY FROM rl.date)::INT AS streak_group
    FROM reading_logs rl
),
     streaks AS (
         SELECT
             u.username,
             COUNT(*) AS streak_length,
             MAX(date) AS last_date
         FROM consecutive_days cd
                  JOIN users u ON cd.userid = u.userid
         GROUP BY u.username, streak_group
     )
SELECT
    username,
    streak_length
FROM streaks
WHERE last_date = CURRENT_DATE  -- Ensure the streak continues up to today
ORDER BY streak_length DESC
    LIMIT 3
`

type GetTopStreaksRow struct {
	Username     string `json:"username"`
	StreakLength int64  `json:"streak_length"`
}

func (q *Queries) GetTopStreaks(ctx context.Context) ([]GetTopStreaksRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopStreaks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopStreaksRow
	for rows.Next() {
		var i GetTopStreaksRow
		if err := rows.Scan(&i.Username, &i.StreakLength); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopStreak = `-- name: GetUserTopStreak :one
WITH consecutive_days AS (
    SELECT
        rl.userid,
        rl.date,
        ROW_NUMBER() OVER (PARTITION BY rl.userid ORDER BY rl.date)
            - EXTRACT(DAY FROM rl.date)::INT AS streak_group
    FROM reading_logs rl
    WHERE rl.userid = $1
),
     streaks AS (
         SELECT
             COUNT(*) AS streak_length,
             MAX(date) AS last_date
         FROM consecutive_days
         GROUP BY streak_group
     )
SELECT
    CASE
        WHEN MAX(streak_length) IS NULL THEN '0'
        ELSE CAST(MAX(streak_length) AS TEXT)
        END AS top_streak
FROM streaks
WHERE last_date = CURRENT_DATE
`

func (q *Queries) GetUserTopStreak(ctx context.Context, userid string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserTopStreak, userid)
	var top_streak string
	err := row.Scan(&top_streak)
	return top_streak, err
}

const updateReadingLog = `-- name: UpdateReadingLog :exec
UPDATE reading_logs
SET minutes_read = $2
WHERE userid = $1
`

type UpdateReadingLogParams struct {
	Userid      string `json:"userid"`
	MinutesRead int32  `json:"minutes_read"`
}

func (q *Queries) UpdateReadingLog(ctx context.Context, arg UpdateReadingLogParams) error {
	_, err := q.db.ExecContext(ctx, updateReadingLog, arg.Userid, arg.MinutesRead)
	return err
}
